


<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Filters &mdash; PyVista 0.21.2 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
        <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/style.css" type="text/css" />
  <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Plotting" href="../plotting/index.html" />
    <link rel="prev" title="Composite Datasets" href="composite.html" />
 

<meta name="description" content="3D plotting and mesh analysis through a streamlined interface for the Visualization Toolkit (VTK)">
<meta name="author" content="PyVista Developers">
<meta name="keywords" content="python, 3D, visualization, plotting, mesh, meshviewer, vtk, open-source">

<!-- this contains PyVista's Google analytics code - please don't copy/paste our tracking ID -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');


  ga('create', 'UA-140243896-1', 'auto');
  ga('send', 'pageview');

</script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/pyvista_logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.21.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
    
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="../why.html">Why PyVista?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../authors.html">Authors &amp; Citation</a></li>
</ul>
<p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting-started/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started/simple.html">Basic API Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples/index.html">Quick Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../external_examples.html">External Examples</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Core API</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="common.html">Datasets</a></li>
<li class="toctree-l2"><a class="reference internal" href="points.html">Point Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="point-grids.html">Point-Based Grids</a></li>
<li class="toctree-l2"><a class="reference internal" href="grids.html">Gridded Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="composite.html">Composite Datasets</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Filters</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dataset-filters">Dataset Filters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#polydata-filters">PolyData Filters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#unstructuredgrid-filters">UnstructuredGrid Filters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composite-filters">Composite Filters</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../plotting/index.html">Plotting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../utilities/index.html">Utilities</a></li>
</ul>

            
          

    
        <p class="caption">
            <span class="caption-text">
            
                Getting Connected
            
            </span>
        </p>
        <ul>
            
                <li class="toctree-l1"><a href="http://slack.pyvista.org"><i class="fa fa-slack fa-fw"></i> Slack Community</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/pyvista/pyvista-support"><i class="fa fa-comment fa-fw"></i> Support</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/pyvista/pyvista"><i class="fa fa-github fa-fw"></i> Source Code</a></li>
            
                <li class="toctree-l1"><a href="https://github.com/pyvista/pyvista/blob/master/CONTRIBUTING.md"><i class="fa fa-gavel fa-fw"></i> Contributing</a></li>
            
                <li class="toctree-l1"><a href="https://doi.org/10.21105/joss.01450"><i class="fa fa-file-text fa-fw"></i> The Paper</a></li>
            
        </ul>
    

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PyVista</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Core API</a> &raquo;</li>
        
      <li>Filters</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/pyvista/pyvista/blob/master/docs/core/filters.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pyvista.filters">
<span id="filters"></span><span id="filters-ref"></span><h1>Filters<a class="headerlink" href="#module-pyvista.filters" title="Permalink to this headline">¶</a></h1>
<p>These classes hold methods to apply general filters to any data type.
By inherritting these classes into the wrapped VTK data structures, a user
can easily apply common filters in an intuitive manner.</p>
<p class="rubric">Example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="k">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">examples</span><span class="o">.</span><span class="n">load_uniform</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Threshold</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">threshold</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="mi">500</span><span class="p">])</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">slc</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">slice</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Clip</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clp</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Contour</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iso</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">contour</span><span class="p">()</span>
</pre></div>
</div>
<div class="section" id="dataset-filters">
<h2>Dataset Filters<a class="headerlink" href="#dataset-filters" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#pyvista.DataSetFilters" title="pyvista.DataSetFilters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.DataSetFilters</span></code></a> is inherited by <a class="reference internal" href="common.html#pyvista.Common" title="pyvista.Common"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.Common</span></code></a> making
all the the following filters available as callable methods directly from any
PyVista dataset.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell_centers</span></code>([vertex])</p></td>
<td><p>Generate points at the center of the cells in this dataset.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell_data_to_point_data</span></code>([pass_cell_data])</p></td>
<td><p>Transforms cell data (i.e., data specified per cell) into point data (i.e., data specified at cell points).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip</span></code>([normal, origin, invert, value, inplace])</p></td>
<td><p>Clip a dataset by a plane by specifying the origin and normal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip_box</span></code>([bounds, invert, factor])</p></td>
<td><p>Clips a dataset by a bounding box defined by the bounds.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_cell_sizes</span></code>([length, area, volume])</p></td>
<td><p>This filter computes sizes for 1D (length), 2D (area) and 3D (volume) cells.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">connectivity</span></code>([largest])</p></td>
<td><p>Find and label connected bodies/volumes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">contour</span></code>([isosurfaces, scalars, …])</p></td>
<td><p>Contours an input dataset by an array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">decimate_boundary</span></code>([target_reduction])</p></td>
<td><p>Return a decimated version of a triangulation of the boundary of this mesh’s outer surface</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">delaunay_3d</span></code>([alpha, tol, offset])</p></td>
<td><p>Constructs a 3D Delaunay triangulation of the mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">elevation</span></code>([low_point, high_point, …])</p></td>
<td><p>Generate scalar values on a dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_cells</span></code>(ind)</p></td>
<td><p>Returns a subset of the grid</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_edges</span></code>([feature_angle, …])</p></td>
<td><p>Extracts edges from the surface of the mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_geometry</span></code>()</p></td>
<td><p>Extract the outer surface of a volume or structured grid dataset as PolyData.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_largest</span></code>([inplace])</p></td>
<td><p>Extract largest connected set in mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_points</span></code>(ind)</p></td>
<td><p>Returns a subset of the grid (with cells) that contains the points that contain any of the given point indices.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_selection_points</span></code>(ind)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_surface</span></code>([pass_pointid, pass_cellid, …])</p></td>
<td><p>Extract surface mesh of the grid</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">glyph</span></code>([orient, scale, factor, geom, …])</p></td>
<td><p>Copies a geometric representation (called a glyph) to every point in the input dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate</span></code>(points[, sharpness, radius, …])</p></td>
<td><p>Interpolate values onto this mesh from the point data of a given <a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code></a> object (typically a point cloud).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge</span></code>([grid, merge_points, inplace, …])</p></td>
<td><p>Join one or many other grids to this grid.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code>([generate_faces])</p></td>
<td><p>Produces an outline of the full extent for the input dataset.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline_corners</span></code>([factor])</p></td>
<td><p>Produces an outline of the corners for the input dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_over_line</span></code>(pointa, pointb[, resolution, …])</p></td>
<td><p>Sample a dataset along a high resolution line and plot the variables of interest in 2D where the X-axis is distance from Point A and the Y-axis is the varaible of interest.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">point_data_to_cell_data</span></code>([pass_point_data])</p></td>
<td><p>Transforms point data (i.e., data specified per node) into cell data (i.e., data specified within cells).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">sample</span></code>(target[, tolerance, …])</p></td>
<td><p>Resample scalar data from a passed mesh onto this mesh using <code class="xref py py-class docutils literal notranslate"><span class="pre">vtk.vtkResampleWithDataSet</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_enclosed_points</span></code>(surface[, tolerance, …])</p></td>
<td><p>Mark points as to whether they are inside a closed surface.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice</span></code>([normal, origin, generate_triangles, …])</p></td>
<td><p>Slice a dataset by a plane at the specified origin and normal vector orientation.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_along_axis</span></code>([n, axis, tolerance, …])</p></td>
<td><p>Create many slices of the input dataset along a specified axis.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_along_line</span></code>(line[, generate_triangles, …])</p></td>
<td><p>Slices a dataset using a polyline/spline as the path.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_orthogonal</span></code>([x, y, z, …])</p></td>
<td><p>Creates three orthogonal slices through the dataset on the three caresian planes.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">split_bodies</span></code>([label])</p></td>
<td><p>Find, label, and split connected bodies/volumes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">streamlines</span></code>([vectors, source_center, …])</p></td>
<td><p>Integrate a vector field to generate streamlines.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">surface_indices</span></code>()</p></td>
<td><p>The surface indices of a grid.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">texture_map_to_plane</span></code>([origin, point_u, …])</p></td>
<td><p>Texture map this dataset to a user defined plane.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold</span></code>([value, scalars, invert, …])</p></td>
<td><p>This filter will apply a <code class="docutils literal notranslate"><span class="pre">vtkThreshold</span></code> filter to the input dataset and return the resulting object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">threshold_percent</span></code>([percent, scalars, …])</p></td>
<td><p>Thresholds the dataset by a percentage of its range on the active scalar array or as specified</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangulate</span></code>([inplace])</p></td>
<td><p>Returns an all triangle mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">warp_by_scalar</span></code>([scalars, factor, normal, …])</p></td>
<td><p>Warp the dataset’s points by a point data scalar array’s values.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">wireframe</span></code>()</p></td>
<td><p>Extract all the internal/external edges of the dataset as PolyData.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="pyvista.DataSetFilters">
<em class="property">class </em><code class="sig-prename descclassname">pyvista.</code><code class="sig-name descname">DataSetFilters</code><a class="headerlink" href="#pyvista.DataSetFilters" title="Permalink to this definition">¶</a></dt>
<dd><p>A set of common filters that can be applied to any vtkDataSet</p>
<dl class="method">
<dt id="pyvista.DataSetFilters.cell_centers">
<code class="sig-name descname">cell_centers</code><span class="sig-paren">(</span><em class="sig-param">vertex=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.cell_centers" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate points at the center of the cells in this dataset.
These points can be used for placing glyphs / vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vertex</strong> (<em>bool</em>) – Enable/disable the generation of vertex cells.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.cell_data_to_point_data">
<code class="sig-name descname">cell_data_to_point_data</code><span class="sig-paren">(</span><em class="sig-param">pass_cell_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.cell_data_to_point_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms cell data (i.e., data specified per cell) into point data
(i.e., data specified at cell points).
The method of transformation is based on averaging the data values of
all cells using a particular point. Optionally, the input cell data can
be passed through to the output as well.</p>
<p>See aslo: <a class="reference internal" href="#pyvista.DataSetFilters.point_data_to_cell_data" title="pyvista.DataSetFilters.point_data_to_cell_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.DataSetFilters.point_data_to_cell_data()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pass_cell_data</strong> (<em>bool</em>) – If enabled, pass the input cell data through to the output</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.clip">
<code class="sig-name descname">clip</code><span class="sig-paren">(</span><em class="sig-param">normal='x'</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">invert=True</em>, <em class="sig-param">value=0.0</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip a dataset by a plane by specifying the origin and normal. If no
parameters are given the clip will occur in the center of that dataset</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normal</strong> (<em>tuple</em><em>(</em><em>float</em><em>) or </em><em>str</em>) – Length 3 tuple for the normal vector direction. Can also be
specified as a string conventional direction such as <code class="docutils literal notranslate"><span class="pre">'x'</span></code> for
<code class="docutils literal notranslate"><span class="pre">(1,0,0)</span></code> or <code class="docutils literal notranslate"><span class="pre">'-x'</span></code> for <code class="docutils literal notranslate"><span class="pre">(-1,0,0)</span></code>, etc.</p></li>
<li><p><strong>origin</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – The center <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code> coordinate of the plane on which the clip
occurs</p></li>
<li><p><strong>invert</strong> (<em>bool</em>) – Flag on whether to flip/invert the clip</p></li>
<li><p><strong>value</strong> (<em>float:</em>) – Set the clipping value of the implicit function (if clipping with
implicit function) or scalar value (if clipping with scalars).
The default value is 0.0.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.clip_box">
<code class="sig-name descname">clip_box</code><span class="sig-paren">(</span><em class="sig-param">bounds=None</em>, <em class="sig-param">invert=True</em>, <em class="sig-param">factor=0.35</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.clip_box" title="Permalink to this definition">¶</a></dt>
<dd><p>Clips a dataset by a bounding box defined by the bounds. If no bounds
are given, a corner of the dataset bounds will be removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – Length 6 iterable of floats: (xmin, xmax, ymin, ymax, zmin, zmax)</p></li>
<li><p><strong>invert</strong> (<em>bool</em>) – Flag on whether to flip/invert the clip</p></li>
<li><p><strong>factor</strong> (<em>float</em><em>, </em><em>optional</em>) – If bounds are not given this is the factor along each axis to
extract the default box.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.compute_cell_sizes">
<code class="sig-name descname">compute_cell_sizes</code><span class="sig-paren">(</span><em class="sig-param">length=True</em>, <em class="sig-param">area=True</em>, <em class="sig-param">volume=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.compute_cell_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>This filter computes sizes for 1D (length), 2D (area) and 3D (volume)
cells.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length</strong> (<em>bool</em>) – Specify whether or not to compute the length of 1D cells.</p></li>
<li><p><strong>area</strong> (<em>bool</em>) – Specify whether or not to compute the area of 2D cells.</p></li>
<li><p><strong>volume</strong> (<em>bool</em>) – Specify whether or not to compute the volume of 3D cells.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.connectivity">
<code class="sig-name descname">connectivity</code><span class="sig-paren">(</span><em class="sig-param">largest=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.connectivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Find and label connected bodies/volumes. This adds an ID array to
the point and cell data to distinguish seperate connected bodies.
This applies a <code class="docutils literal notranslate"><span class="pre">vtkConnectivityFilter</span></code> filter which extracts cells
that share common points and/or meet other connectivity criterion.
(Cells that share vertices and meet other connectivity criterion such
as scalar range are known as a region.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>largest</strong> (<em>bool</em>) – Extract the largest connected part of the mesh.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.contour">
<code class="sig-name descname">contour</code><span class="sig-paren">(</span><em class="sig-param">isosurfaces=10</em>, <em class="sig-param">scalars=None</em>, <em class="sig-param">compute_normals=False</em>, <em class="sig-param">compute_gradients=False</em>, <em class="sig-param">compute_scalars=True</em>, <em class="sig-param">rng=None</em>, <em class="sig-param">preference='point'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.contour" title="Permalink to this definition">¶</a></dt>
<dd><p>Contours an input dataset by an array. <code class="docutils literal notranslate"><span class="pre">isosurfaces</span></code> can be an integer
specifying the number of isosurfaces in the data range or an iterable set of
values for explicitly setting the isosurfaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>isosurfaces</strong> (<em>int</em><em> or </em><em>iterable</em>) – Number of isosurfaces to compute across valid data range or an
iterable of float values to explicitly use as the isosurfaces.</p></li>
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of scalars to threshold on. Defaults to currently active scalars.</p></li>
<li><p><strong>compute_normals</strong> (<em>bool</em><em>, </em><em>optional</em>) – </p></li>
<li><p><strong>compute_gradients</strong> (<em>bool</em><em>, </em><em>optional</em>) – Desc</p></li>
<li><p><strong>compute_scalars</strong> (<em>bool</em><em>, </em><em>optional</em>) – Preserves the scalar values that are being contoured</p></li>
<li><p><strong>rng</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – If an integer number of isosurfaces is specified, this is the range
over which to generate contours. Default is the scalar arrays’s full
data range.</p></li>
<li><p><strong>preference</strong> (<em>str</em><em>, </em><em>optional</em>) – When scalars is specified, this is the perfered scalar type to
search for in the dataset.  Must be either <code class="docutils literal notranslate"><span class="pre">'point'</span></code> or <code class="docutils literal notranslate"><span class="pre">'cell'</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.decimate_boundary">
<code class="sig-name descname">decimate_boundary</code><span class="sig-paren">(</span><em class="sig-param">target_reduction=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.decimate_boundary" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a decimated version of a triangulation of the boundary of
this mesh’s outer surface</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>target_reduction</strong> (<em>float</em>) – Fraction of the original mesh to remove. Default is <code class="docutils literal notranslate"><span class="pre">0.5</span></code>
TargetReduction is set to <code class="docutils literal notranslate"><span class="pre">0.9</span></code>, this filter will try to reduce
the data set to 10% of its original size and will remove 90%
of the input triangles.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.delaunay_3d">
<code class="sig-name descname">delaunay_3d</code><span class="sig-paren">(</span><em class="sig-param">alpha=0</em>, <em class="sig-param">tol=0.001</em>, <em class="sig-param">offset=2.5</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.delaunay_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a 3D Delaunay triangulation of the mesh.
This helps smooth out a rugged mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> (<em>float</em><em>, </em><em>optional</em>) – Distance value to control output of this filter. For a non-zero
alpha value, only verts, edges, faces, or tetra contained within
the circumsphere (of radius alpha) will be output. Otherwise, only
tetrahedra will be output.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – tolerance to control discarding of closely spaced points.
This tolerance is specified as a fraction of the diagonal length
of the bounding box of the points.</p></li>
<li><p><strong>offset</strong> (<em>float</em><em>, </em><em>optional</em>) – multiplier to control the size of the initial, bounding Delaunay
triangulation.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.elevation">
<code class="sig-name descname">elevation</code><span class="sig-paren">(</span><em class="sig-param">low_point=None</em>, <em class="sig-param">high_point=None</em>, <em class="sig-param">scalar_range=None</em>, <em class="sig-param">preference='point'</em>, <em class="sig-param">set_active=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.elevation" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate scalar values on a dataset.  The scalar values lie within a
user specified range, and are generated by computing a projection of
each dataset point onto a line.
The line can be oriented arbitrarily.
A typical example is to generate scalars based on elevation or height
above a plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>low_point</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The low point of the projection line in 3D space. Default is bottom
center of the dataset. Otherwise pass a length 3 tuple(float).</p></li>
<li><p><strong>high_point</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The high point of the projection line in 3D space. Default is top
center of the dataset. Otherwise pass a length 3 tuple(float).</p></li>
<li><p><strong>scalar_range</strong> (<em>str</em><em> or </em><em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The scalar range to project to the low and high points on the line
that will be mapped to the dataset. If None given, the values will
be computed from the elevation (Z component) range between the
high and low points. Min and max of a range can be given as a length
2 tuple(float). If <code class="docutils literal notranslate"><span class="pre">str</span></code> name of scalara array present in the
dataset given, the valid range of that array will be used.</p></li>
<li><p><strong>preference</strong> (<em>str</em><em>, </em><em>optional</em>) – When a scalar name is specified for <code class="docutils literal notranslate"><span class="pre">scalar_range</span></code>, this is the
perfered scalar type to search for in the dataset.
Must be either ‘point’ or ‘cell’.</p></li>
<li><p><strong>set_active</strong> (<em>bool</em><em>, </em><em>optional</em>) – A boolean flag on whethter or not to set the new <cite>Elevation</cite> scalar
as the active scalar array on the output dataset.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This will create a scalar array named <cite>Elevation</cite> on the point data of
the input dataset and overasdf write an array named <cite>Elevation</cite> if present.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.extract_cells">
<code class="sig-name descname">extract_cells</code><span class="sig-paren">(</span><em class="sig-param">ind</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.extract_cells" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a subset of the grid</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ind</strong> (<em>np.ndarray</em>) – Numpy array of cell indices to be extracted.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>subgrid</strong> – Subselected grid</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="point-grids.html#pyvista.UnstructuredGrid" title="pyvista.UnstructuredGrid">pyvista.UnstructuredGrid</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.extract_edges">
<code class="sig-name descname">extract_edges</code><span class="sig-paren">(</span><em class="sig-param">feature_angle=30</em>, <em class="sig-param">boundary_edges=True</em>, <em class="sig-param">non_manifold_edges=True</em>, <em class="sig-param">feature_edges=True</em>, <em class="sig-param">manifold_edges=True</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.extract_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts edges from the surface of the mesh. If the given mesh is not
PolyData, the external surface of the given mesh is extracted and used.
From vtk documentation, the edges are one of the following</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>boundary (used by one polygon) or a line cell</p></li>
<li><p>non-manifold (used by three or more polygons)</p></li>
<li><p>feature edges (edges used by two triangles and whose
dihedral angle &gt; feature_angle)</p></li>
<li><p>manifold edges (edges used by exactly two polygons).</p></li>
</ol>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>feature_angle</strong> (<em>float</em><em>, </em><em>optional</em>) – Defaults to 30 degrees.</p></li>
<li><p><strong>boundary_edges</strong> (<em>bool</em><em>, </em><em>optional</em>) – Defaults to True</p></li>
<li><p><strong>non_manifold_edges</strong> (<em>bool</em><em>, </em><em>optional</em>) – Defaults to True</p></li>
<li><p><strong>feature_edges</strong> (<em>bool</em><em>, </em><em>optional</em>) – Defaults to True</p></li>
<li><p><strong>manifold_edges</strong> (<em>bool</em><em>, </em><em>optional</em>) – Defaults to True</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return new mesh or overwrite input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>edges</strong> – Extracted edges. None if inplace=True.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pyvista.vtkPolyData</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.extract_geometry">
<code class="sig-name descname">extract_geometry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.extract_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the outer surface of a volume or structured grid dataset as
PolyData. This will extract all 0D, 1D, and 2D cells producing the
boundary faces of the dataset.</p>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.extract_largest">
<code class="sig-name descname">extract_largest</code><span class="sig-paren">(</span><em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.extract_largest" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract largest connected set in mesh.</p>
<p>Can be used to reduce residues obtained when generating an isosurface.
Works only if residues are not connected (share at least one point with)
the main component of the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Largest connected set in mesh</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.extract_points">
<code class="sig-name descname">extract_points</code><span class="sig-paren">(</span><em class="sig-param">ind</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.extract_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a subset of the grid (with cells) that contains the points
that contain any of the given point indices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ind</strong> (<em>np.ndarray</em><em>, </em><em>list</em><em>, or </em><em>iterable</em>) – Numpy array of point indices to be extracted.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>subgrid</strong> – Subselected grid.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="point-grids.html#pyvista.UnstructuredGrid" title="pyvista.UnstructuredGrid">pyvista.UnstructuredGrid</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.extract_selection_points">
<code class="sig-name descname">extract_selection_points</code><span class="sig-paren">(</span><em class="sig-param">ind</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.extract_selection_points" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.extract_surface">
<code class="sig-name descname">extract_surface</code><span class="sig-paren">(</span><em class="sig-param">pass_pointid=True</em>, <em class="sig-param">pass_cellid=True</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.extract_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract surface mesh of the grid</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pass_pointid</strong> (<em>bool</em><em>, </em><em>optional</em>) – Adds a point scalar “vtkOriginalPointIds” that idenfities which
original points these surface points correspond to</p></li>
<li><p><strong>pass_cellid</strong> (<em>bool</em><em>, </em><em>optional</em>) – Adds a cell scalar “vtkOriginalPointIds” that idenfities which
original cells these surface cells correspond to</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return new mesh or overwrite input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>extsurf</strong> – Surface mesh of the grid</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.glyph">
<code class="sig-name descname">glyph</code><span class="sig-paren">(</span><em class="sig-param">orient=True</em>, <em class="sig-param">scale=True</em>, <em class="sig-param">factor=1.0</em>, <em class="sig-param">geom=None</em>, <em class="sig-param">tolerance=0.0</em>, <em class="sig-param">absolute=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.glyph" title="Permalink to this definition">¶</a></dt>
<dd><p>Copies a geometric representation (called a glyph) to every
point in the input dataset.  The glyph may be oriented along
the input vectors, and it may be scaled according to scalar
data or vector magnitude.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orient</strong> (<em>bool</em>) – Use the active vectors array to orient the the glyphs</p></li>
<li><p><strong>scale</strong> (<em>bool</em>) – Use the active scalars to scale the glyphs</p></li>
<li><p><strong>factor</strong> (<em>float</em>) – Scale factor applied to sclaing array</p></li>
<li><p><strong>geom</strong> (<em>vtk.vtkDataSet</em>) – The geometry to use for the glyph</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – Specify tolerance in terms of fraction of bounding box length.
Float value is between 0 and 1. Default is 0.0. If <code class="docutils literal notranslate"><span class="pre">absolute</span></code>
is <code class="docutils literal notranslate"><span class="pre">True</span></code> then the tolerance can be an absolute distance.</p></li>
<li><p><strong>absolute</strong> (<em>bool</em><em>, </em><em>optional</em>) – Control if <code class="docutils literal notranslate"><span class="pre">tolerance</span></code> is an absolute distance or a fraction.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.interpolate">
<code class="sig-name descname">interpolate</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">sharpness=2</em>, <em class="sig-param">radius=1.0</em>, <em class="sig-param">dimensions=(101</em>, <em class="sig-param">101</em>, <em class="sig-param">101)</em>, <em class="sig-param">pass_cell_arrays=True</em>, <em class="sig-param">pass_point_arrays=True</em>, <em class="sig-param">null_value=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate values onto this mesh from the point data of a given
<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code></a> object (typically a point cloud).</p>
<p>This uses a guassian interpolation kernel. Use the <code class="docutils literal notranslate"><span class="pre">sharpness</span></code> and
<code class="docutils literal notranslate"><span class="pre">radius</span></code> parameters to adjust this kernel.</p>
<p>Please note that the source dataset is first interpolated onto a fine
UniformGrid which is then sampled to this mesh. The interpolation grid’s
dimensions will likely need to be tweaked for each individual use case.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – The points whose values will be interpolated onto this mesh.</p></li>
<li><p><strong>sharpness</strong> (<em>float</em>) – Set / Get the sharpness (i.e., falloff) of the Gaussian. By
default Sharpness=2. As the sharpness increases the effects of
distant points are reduced.</p></li>
<li><p><strong>radius</strong> (<em>float</em>) – Specify the radius within which the basis points must lie.</p></li>
<li><p><strong>dimensions</strong> (<em>tuple</em><em>(</em><em>int</em><em>)</em>) – When interpolating the points, they are first interpolating on to a
<a class="reference internal" href="grids.html#pyvista.UniformGrid" title="pyvista.UniformGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.UniformGrid</span></code></a> with the same spatial extent -
<code class="docutils literal notranslate"><span class="pre">dimensions</span></code> is number of points along each axis for that grid.</p></li>
<li><p><strong>pass_cell_arrays</strong> (<em>bool</em><em>, </em><em>optional</em>) – Preserve source mesh’s original cell data arrays</p></li>
<li><p><strong>pass_point_arrays</strong> (<em>bool</em><em>, </em><em>optional</em>) – Preserve source mesh’s original point data arrays</p></li>
<li><p><strong>null_value</strong> (<em>float</em><em>, </em><em>optional</em>) – Specify the null point value. When a null point is encountered
then all components of each null tuple are set to this value. By
default the null value is set to zero.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.merge">
<code class="sig-name descname">merge</code><span class="sig-paren">(</span><em class="sig-param">grid=None</em>, <em class="sig-param">merge_points=True</em>, <em class="sig-param">inplace=False</em>, <em class="sig-param">main_has_priority=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Join one or many other grids to this grid.  Grid is updated
in-place by default.</p>
<p>Can be used to merge points of adjcent cells when no grids
are input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid</strong> (<em>vtk.UnstructuredGrid</em><em> or </em><em>list of vtk.UnstructuredGrids</em>) – Grids to merge to this grid.</p></li>
<li><p><strong>merge_points</strong> (<em>bool</em><em>, </em><em>optional</em>) – Points in exactly the same location will be merged between
the two meshes.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates grid inplace when True.</p></li>
<li><p><strong>main_has_priority</strong> (<em>bool</em><em>, </em><em>optional</em>) – When this parameter is true and merge_points is true,
the scalar arrays of the merging grids will be overwritten
by the original main mesh.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>merged_grid</strong> – Merged grid.  Returned when inplace is False.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>vtk.UnstructuredGrid</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>When two or more grids are joined, the type and name of each
scalar array must match or the arrays will be ignored and not
included in the final merged mesh.</p>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.outline">
<code class="sig-name descname">outline</code><span class="sig-paren">(</span><em class="sig-param">generate_faces=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.outline" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces an outline of the full extent for the input dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>generate_faces</strong> (<em>bool</em><em>, </em><em>optional</em>) – Generate solid faces for the box. This is off by default</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.outline_corners">
<code class="sig-name descname">outline_corners</code><span class="sig-paren">(</span><em class="sig-param">factor=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.outline_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces an outline of the corners for the input dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>factor</strong> (<em>float</em><em>, </em><em>optional</em>) – controls the relative size of the corners to the length of the
corresponding bounds</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.plot_over_line">
<code class="sig-name descname">plot_over_line</code><span class="sig-paren">(</span><em class="sig-param">pointa</em>, <em class="sig-param">pointb</em>, <em class="sig-param">resolution=None</em>, <em class="sig-param">scalars=None</em>, <em class="sig-param">title=None</em>, <em class="sig-param">ylabel=None</em>, <em class="sig-param">figsize=None</em>, <em class="sig-param">figure=True</em>, <em class="sig-param">show=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.plot_over_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample a dataset along a high resolution line and plot the variables
of interest in 2D where the X-axis is distance from Point A and the
Y-axis is the varaible of interest. Note that this filter returns None.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pointa</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Location in [x, y, z].</p></li>
<li><p><strong>pointb</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Location in [x, y, z].</p></li>
<li><p><strong>resolution</strong> (<em>int</em>) – number of pieces to divide line into. Defaults to number of cells
in the input mesh. Must be a positive integer.</p></li>
<li><p><strong>scalars</strong> (<em>str</em>) – The string name of the variable in the input dataset to probe. The
active scalar is used by default.</p></li>
<li><p><strong>title</strong> (<em>str</em>) – The string title of the <cite>matplotlib</cite> figure</p></li>
<li><p><strong>ylabel</strong> (<em>str</em>) – The string label of the Y-axis. Defaults to variable name</p></li>
<li><p><strong>figsize</strong> (<em>tuple</em><em>(</em><em>int</em><em>)</em>) – the size of the new figure</p></li>
<li><p><strong>figure</strong> (<em>bool</em>) – flag on whether or not to create a new figure</p></li>
<li><p><strong>show</strong> (<em>bool</em>) – Shows the matplotlib figure</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.point_data_to_cell_data">
<code class="sig-name descname">point_data_to_cell_data</code><span class="sig-paren">(</span><em class="sig-param">pass_point_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.point_data_to_cell_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms point data (i.e., data specified per node) into cell data
(i.e., data specified within cells).
Optionally, the input point data can be passed through to the output.</p>
<p>See aslo: <a class="reference internal" href="#pyvista.DataSetFilters.cell_data_to_point_data" title="pyvista.DataSetFilters.cell_data_to_point_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.DataSetFilters.cell_data_to_point_data()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pass_point_data</strong> (<em>bool</em>) – If enabled, pass the input point data through to the output</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.sample">
<code class="sig-name descname">sample</code><span class="sig-paren">(</span><em class="sig-param">target</em>, <em class="sig-param">tolerance=None</em>, <em class="sig-param">pass_cell_arrays=True</em>, <em class="sig-param">pass_point_arrays=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample scalar data from a passed mesh onto this mesh using
<code class="xref py py-class docutils literal notranslate"><span class="pre">vtk.vtkResampleWithDataSet</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dataset</strong> (<a class="reference internal" href="common.html#pyvista.Common" title="pyvista.Common"><em>pyvista.Common</em></a>) – The source vtk data object as the mesh to sample values on to</p></li>
<li><p><strong>target</strong> (<a class="reference internal" href="common.html#pyvista.Common" title="pyvista.Common"><em>pyvista.Common</em></a>) – The vtk data object to sample from - point and cell arrays from
this object are sampled onto the nodes of the <code class="docutils literal notranslate"><span class="pre">dataset</span></code> mesh</p></li>
<li><p><strong>tolerance</strong> (<em>flaot</em><em>, </em><em>optional</em>) – tolerance used to compute whether a point in the source is in a
cell of the input.  If not given, tolerance automatically generated.</p></li>
<li><p><strong>pass_cell_arrays</strong> (<em>bool</em><em>, </em><em>optional</em>) – Preserve source mesh’s original cell data arrays</p></li>
<li><p><strong>pass_point_arrays</strong> (<em>bool</em><em>, </em><em>optional</em>) – Preserve source mesh’s original point data arrays</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.select_enclosed_points">
<code class="sig-name descname">select_enclosed_points</code><span class="sig-paren">(</span><em class="sig-param">surface</em>, <em class="sig-param">tolerance=0.001</em>, <em class="sig-param">inside_out=False</em>, <em class="sig-param">check_surface=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.select_enclosed_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark points as to whether they are inside a closed surface.
This evaluates all the input points to determine whether they are in an
enclosed surface. The filter produces a (0,1) mask
(in the form of a vtkDataArray) that indicates whether points are
outside (mask value=0) or inside (mask value=1) a provided surface.
(The name of the output vtkDataArray is “SelectedPointsArray”.)</p>
<p>The filter assumes that the surface is closed and manifold. A boolean
flag can be set to force the filter to first check whether this is
true. If false, all points will be marked outside. Note that if this
check is not performed and the surface is not closed, the results are
undefined.</p>
<p>This filter produces and output data array, but does not modify the
input dataset. If you wish to extract cells or poinrs, various
threshold filters are available (i.e., threshold the output array).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surface</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – Set the surface to be used to test for containment. This must be a
<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code></a> object.</p></li>
<li><p><strong>tolerance</strong> (<em>float</em>) – The tolerance on the intersection. The tolerance is expressed as a
fraction of the bounding box of the enclosing surface.</p></li>
<li><p><strong>inside_out</strong> (<em>bool</em>) – By default, points inside the surface are marked inside or sent
to the output. If <code class="docutils literal notranslate"><span class="pre">inside_out</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the points
outside the surface are marked inside.</p></li>
<li><p><strong>check_surface</strong> (<em>bool</em>) – Specify whether to check the surface for closure. If on, then the
algorithm first checks to see if the surface is closed and
manifold.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.slice">
<code class="sig-name descname">slice</code><span class="sig-paren">(</span><em class="sig-param">normal='x'</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">generate_triangles=False</em>, <em class="sig-param">contour=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice a dataset by a plane at the specified origin and normal vector
orientation. If no origin is specified, the center of the input dataset will
be used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normal</strong> (<em>tuple</em><em>(</em><em>float</em><em>) or </em><em>str</em>) – Length 3 tuple for the normal vector direction. Can also be
specified as a string conventional direction such as <code class="docutils literal notranslate"><span class="pre">'x'</span></code> for
<code class="docutils literal notranslate"><span class="pre">(1,0,0)</span></code> or <code class="docutils literal notranslate"><span class="pre">'-x'</span></code> for <code class="docutils literal notranslate"><span class="pre">(-1,0,0)`</span></code>, etc.</p></li>
<li><p><strong>origin</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – The center (x,y,z) coordinate of the plane on which the slice occurs</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.slice_along_axis">
<code class="sig-name descname">slice_along_axis</code><span class="sig-paren">(</span><em class="sig-param">n=5</em>, <em class="sig-param">axis='x'</em>, <em class="sig-param">tolerance=None</em>, <em class="sig-param">generate_triangles=False</em>, <em class="sig-param">contour=False</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">center=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.slice_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create many slices of the input dataset along a specified axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of slices to create</p></li>
<li><p><strong>axis</strong> (<em>str</em><em> or </em><em>int</em>) – The axis to generate the slices along. Perpendicular to the slices.
Can be string name (<code class="docutils literal notranslate"><span class="pre">'x'</span></code>, <code class="docutils literal notranslate"><span class="pre">'y'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'z'</span></code>) or axis index
(<code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, or <code class="docutils literal notranslate"><span class="pre">2</span></code>).</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – The toleranceerance to the edge of the dataset bounds to create the slices</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.slice_along_line">
<code class="sig-name descname">slice_along_line</code><span class="sig-paren">(</span><em class="sig-param">line</em>, <em class="sig-param">generate_triangles=False</em>, <em class="sig-param">contour=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.slice_along_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Slices a dataset using a polyline/spline as the path. This also works
for lines generated with <a class="reference internal" href="../utilities/geometric.html#pyvista.Line" title="pyvista.Line"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.Line()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – A PolyData object containing one single PolyLine cell.</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.slice_orthogonal">
<code class="sig-name descname">slice_orthogonal</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">y=None</em>, <em class="sig-param">z=None</em>, <em class="sig-param">generate_triangles=False</em>, <em class="sig-param">contour=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.slice_orthogonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates three orthogonal slices through the dataset on the three
caresian planes. Yields a MutliBlock dataset of the three slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>float</em>) – The X location of the YZ slice</p></li>
<li><p><strong>y</strong> (<em>float</em>) – The Y location of the XZ slice</p></li>
<li><p><strong>z</strong> (<em>float</em>) – The Z location of the XY slice</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.split_bodies">
<code class="sig-name descname">split_bodies</code><span class="sig-paren">(</span><em class="sig-param">label=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.split_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Find, label, and split connected bodies/volumes. This splits
different connected bodies into blocks in a MultiBlock dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>label</strong> (<em>bool</em>) – A flag on whether to keep the ID arrays given by the
<code class="docutils literal notranslate"><span class="pre">connectivity</span></code> filter.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.streamlines">
<code class="sig-name descname">streamlines</code><span class="sig-paren">(</span><em class="sig-param">vectors=None</em>, <em class="sig-param">source_center=None</em>, <em class="sig-param">source_radius=None</em>, <em class="sig-param">n_points=100</em>, <em class="sig-param">integrator_type=45</em>, <em class="sig-param">integration_direction='both'</em>, <em class="sig-param">surface_streamlines=False</em>, <em class="sig-param">initial_step_length=0.5</em>, <em class="sig-param">step_unit='cl'</em>, <em class="sig-param">min_step_length=0.01</em>, <em class="sig-param">max_step_length=1.0</em>, <em class="sig-param">max_steps=2000</em>, <em class="sig-param">terminal_speed=1e-12</em>, <em class="sig-param">max_error=1e-06</em>, <em class="sig-param">max_time=None</em>, <em class="sig-param">compute_vorticity=True</em>, <em class="sig-param">rotation_scale=1.0</em>, <em class="sig-param">interpolator_type='point'</em>, <em class="sig-param">start_position=(0.0</em>, <em class="sig-param">0.0</em>, <em class="sig-param">0.0)</em>, <em class="sig-param">return_source=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.streamlines" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrate a vector field to generate streamlines. The integration is
performed using a specified integrator, by default Runge-Kutta2.
This supports integration through any type of dataset.
Thus if the dataset contains 2D cells like polygons or triangles, the
integration is constrained to lie on the surface defined by 2D cells.</p>
<p>This produces polylines as the output, with each cell
(i.e., polyline) representing a streamline. The attribute values
associated with each streamline are stored in the cell data, whereas
those associated with streamline-points are stored in the point data.</p>
<p>This uses a Sphere as the source - set it’s location and radius via
the <code class="docutils literal notranslate"><span class="pre">source_center</span></code> and <code class="docutils literal notranslate"><span class="pre">source_radius</span></code> keyword arguments.
You can retrieve the source as <a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code></a> by specifying
<code class="docutils literal notranslate"><span class="pre">return_source=True</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vectors</strong> (<em>str</em>) – The string name of the active vector field to integrate across</p></li>
<li><p><strong>source_center</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – Length 3 tuple of floats defining the center of the source
particles. Defaults to the center of the dataset</p></li>
<li><p><strong>source_radius</strong> (<em>float</em>) – Float radius of the source particle cloud. Defaults to one-tenth of
the diagonal of the dataset’s spatial extent</p></li>
<li><p><strong>n_points</strong> (<em>int</em>) – Number of particles present in source sphere</p></li>
<li><p><strong>integrator_type</strong> (<em>int</em>) – The integrator type to be used for streamline generation.
The default is Runge-Kutta45. The recognized solvers are:
RUNGE_KUTTA2 (<code class="docutils literal notranslate"><span class="pre">2</span></code>),  RUNGE_KUTTA4 (<code class="docutils literal notranslate"><span class="pre">4</span></code>), and RUNGE_KUTTA45
(<code class="docutils literal notranslate"><span class="pre">45</span></code>). Options are <code class="docutils literal notranslate"><span class="pre">2</span></code>, <code class="docutils literal notranslate"><span class="pre">4</span></code>, or <code class="docutils literal notranslate"><span class="pre">45</span></code>. Default is <code class="docutils literal notranslate"><span class="pre">45</span></code>.</p></li>
<li><p><strong>integration_direction</strong> (<em>str</em>) – Specify whether the streamline is integrated in the upstream or
downstream directions (or both). Options are <code class="docutils literal notranslate"><span class="pre">'both'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'backward'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'forward'</span></code>.</p></li>
<li><p><strong>surface_streamlines</strong> (<em>bool</em>) – Compute streamlines on a surface. Default <code class="docutils literal notranslate"><span class="pre">False</span></code></p></li>
<li><p><strong>initial_step_length</strong> (<em>float</em>) – Initial step size used for line integration, expressed ib length
unitsL or cell length units (see <code class="docutils literal notranslate"><span class="pre">step_unit</span></code> parameter).
either the starting size for an adaptive integrator, e.g., RK45, or
the constant / fixed size for non-adaptive ones, i.e., RK2 and RK4)</p></li>
<li><p><strong>step_unit</strong> (<em>str</em>) – Uniform integration step unit. The valid unit is now limited to
only LENGTH_UNIT (<code class="docutils literal notranslate"><span class="pre">'l'</span></code>) and CELL_LENGTH_UNIT (<code class="docutils literal notranslate"><span class="pre">'cl'</span></code>).
Default is CELL_LENGTH_UNIT: <code class="docutils literal notranslate"><span class="pre">'cl'</span></code>.</p></li>
<li><p><strong>min_step_length</strong> (<em>float</em>) – Minimum step size used for line integration, expressed in length or
cell length units. Only valid for an adaptive integrator, e.g., RK45</p></li>
<li><p><strong>max_step_length</strong> (<em>float</em>) – Maxmimum step size used for line integration, expressed in length or
cell length units. Only valid for an adaptive integrator, e.g., RK45</p></li>
<li><p><strong>max_steps</strong> (<em>int</em>) – Maximum number of steps for integrating a streamline.
Defaults to <code class="docutils literal notranslate"><span class="pre">2000</span></code></p></li>
<li><p><strong>terminal_speed</strong> (<em>float</em>) – Terminal speed value, below which integration is terminated.</p></li>
<li><p><strong>max_error</strong> (<em>float</em>) – Maximum error tolerated throughout streamline integration.</p></li>
<li><p><strong>max_time</strong> (<em>float</em>) – Specify the maximum length of a streamline expressed in LENGTH_UNIT.</p></li>
<li><p><strong>compute_vorticity</strong> (<em>bool</em>) – Vorticity computation at streamline points (necessary for generating
proper stream-ribbons using the <code class="docutils literal notranslate"><span class="pre">vtkRibbonFilter</span></code>.</p></li>
<li><p><strong>interpolator_type</strong> (<em>str</em>) – Set the type of the velocity field interpolator to locate cells
during streamline integration either by points or cells.
The cell locator is more robust then the point locator. Options
are <code class="docutils literal notranslate"><span class="pre">'point'</span></code> or <code class="docutils literal notranslate"><span class="pre">'cell'</span></code> (abreviations of <code class="docutils literal notranslate"><span class="pre">'p'</span></code> and <code class="docutils literal notranslate"><span class="pre">'c'</span></code>
are also supported).</p></li>
<li><p><strong>rotation_scale</strong> (<em>float</em>) – This can be used to scale the rate with which the streamribbons
twist. The default is 1.</p></li>
<li><p><strong>start_position</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – Set the start position. Default is <code class="docutils literal notranslate"><span class="pre">(0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0)</span></code></p></li>
<li><p><strong>return_source</strong> (<em>bool</em>) – Return the source particles as <a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code></a> as well as the
streamlines. This will be the second value returned if <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.surface_indices">
<code class="sig-name descname">surface_indices</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.surface_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>The surface indices of a grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>surf_ind</strong> – Indices of the surface points.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.texture_map_to_plane">
<code class="sig-name descname">texture_map_to_plane</code><span class="sig-paren">(</span><em class="sig-param">origin=None</em>, <em class="sig-param">point_u=None</em>, <em class="sig-param">point_v=None</em>, <em class="sig-param">inplace=False</em>, <em class="sig-param">name='Texture Coordinates'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.texture_map_to_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Texture map this dataset to a user defined plane. This is often used
to define a plane to texture map an image to this dataset. The plane
defines the spatial reference and extent of that image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – Length 3 iterable of floats defining the XYZ coordinates of the
BOTTOM LEFT CORNER of the plane</p></li>
<li><p><strong>point_u</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – Length 3 iterable of floats defining the XYZ coordinates of the
BOTTOM RIGHT CORNER of the plane</p></li>
<li><p><strong>point_v</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – Length 3 iterable of floats defining the XYZ coordinates of the
TOP LEFT CORNER of the plane</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, the new texture coordinates will be added to the dataset
inplace. If False (default), a new dataset is returned with the
textures coordinates</p></li>
<li><p><strong>name</strong> (<em>str</em><em>, </em><em>optional</em>) – The string name to give the new texture coordinates if applying
the filter inplace.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.threshold">
<code class="sig-name descname">threshold</code><span class="sig-paren">(</span><em class="sig-param">value=None</em>, <em class="sig-param">scalars=None</em>, <em class="sig-param">invert=False</em>, <em class="sig-param">continuous=False</em>, <em class="sig-param">preference='cell'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>This filter will apply a <code class="docutils literal notranslate"><span class="pre">vtkThreshold</span></code> filter to the input dataset and
return the resulting object. This extracts cells where scalar value in each
cell satisfies threshold criterion.  If scalars is None, the inputs
active_scalar is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<em>float</em><em> or </em><em>iterable</em><em>, </em><em>optional</em>) – Single value or (min, max) to be used for the data threshold.  If
iterable, then length must be 2. If no value is specified, the
non-NaN data range will be used to remove any NaN values.</p></li>
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of scalars to threshold on. Defaults to currently active scalars.</p></li>
<li><p><strong>invert</strong> (<em>bool</em><em>, </em><em>optional</em>) – If value is a single value, when invert is True cells are kept when
their values are below parameter “value”.  When invert is False
cells are kept when their value is above the threshold “value”.
Default is False: yielding above the threshold “value”.</p></li>
<li><p><strong>continuous</strong> (<em>bool</em><em>, </em><em>optional</em>) – When True, the continuous interval [minimum cell scalar,
maxmimum cell scalar] will be used to intersect the threshold bound,
rather than the set of discrete scalar values from the vertices.</p></li>
<li><p><strong>preference</strong> (<em>str</em><em>, </em><em>optional</em>) – When scalars is specified, this is the perfered scalar type to
search for in the dataset.  Must be either <code class="docutils literal notranslate"><span class="pre">'point'</span></code> or <code class="docutils literal notranslate"><span class="pre">'cell'</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.threshold_percent">
<code class="sig-name descname">threshold_percent</code><span class="sig-paren">(</span><em class="sig-param">percent=0.5</em>, <em class="sig-param">scalars=None</em>, <em class="sig-param">invert=False</em>, <em class="sig-param">continuous=False</em>, <em class="sig-param">preference='cell'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.threshold_percent" title="Permalink to this definition">¶</a></dt>
<dd><p>Thresholds the dataset by a percentage of its range on the active
scalar array or as specified</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>percent</strong> (<em>float</em><em> or </em><em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The percentage (0,1) to threshold. If value is out of 0 to 1 range,
then it will be divided by 100 and checked to be in that range.</p></li>
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of scalars to threshold on. Defaults to currently active scalars.</p></li>
<li><p><strong>invert</strong> (<em>bool</em><em>, </em><em>optional</em>) – When invert is True cells are kept when their values are below the
percentage of the range.  When invert is False, cells are kept when
their value is above the percentage of the range.
Default is False: yielding above the threshold “value”.</p></li>
<li><p><strong>continuous</strong> (<em>bool</em><em>, </em><em>optional</em>) – When True, the continuous interval [minimum cell scalar,
maxmimum cell scalar] will be used to intersect the threshold bound,
rather than the set of discrete scalar values from the vertices.</p></li>
<li><p><strong>preference</strong> (<em>str</em><em>, </em><em>optional</em>) – When scalars is specified, this is the perfered scalar type to
search for in the dataset.  Must be either <code class="docutils literal notranslate"><span class="pre">'point'</span></code> or <code class="docutils literal notranslate"><span class="pre">'cell'</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.triangulate">
<code class="sig-name descname">triangulate</code><span class="sig-paren">(</span><em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.triangulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an all triangle mesh.  More complex polygons will be broken
down into triangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Mesh containing only triangles. <code class="docutils literal notranslate"><span class="pre">None</span></code> when <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="point-grids.html#pyvista.UnstructuredGrid" title="pyvista.UnstructuredGrid">pyvista.UnstructuredGrid</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.warp_by_scalar">
<code class="sig-name descname">warp_by_scalar</code><span class="sig-paren">(</span><em class="sig-param">scalars=None</em>, <em class="sig-param">factor=1.0</em>, <em class="sig-param">normal=None</em>, <em class="sig-param">inplace=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.warp_by_scalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Warp the dataset’s points by a point data scalar array’s values.
This modifies point coordinates by moving points along point normals by
the scalar amount times the scale factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – Name of scalars to warb by. Defaults to currently active scalars.</p></li>
<li><p><strong>factor</strong> (<em>float</em><em>, </em><em>optional</em>) – A scalaing factor to increase the scaling effect. Alias
<code class="docutils literal notranslate"><span class="pre">scale_factor</span></code> also accepted - if present, overrides <code class="docutils literal notranslate"><span class="pre">factor</span></code>.</p></li>
<li><p><strong>normal</strong> (<em>np.array</em><em>, </em><em>list</em><em>, </em><em>tuple of length 3</em>) – User specified normal. If given, data normals will be ignored and
the given normal will be used to project the warp.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em>) – If True, the points of the give dataset will be updated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.DataSetFilters.wireframe">
<code class="sig-name descname">wireframe</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.DataSetFilters.wireframe" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract all the internal/external edges of the dataset as PolyData.
This produces a full wireframe representation of the input dataset.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="polydata-filters">
<h2>PolyData Filters<a class="headerlink" href="#polydata-filters" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#pyvista.PolyDataFilters" title="pyvista.PolyDataFilters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyDataFilters</span></code></a> is inherited by <a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.PolyData</span></code></a>
making all the the following filters available as callable methods directly
from any PolyData mesh.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean_add</span></code>(mesh[, inplace])</p></td>
<td><p>Add a mesh to the current mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean_cut</span></code>(cut[, tolerance, inplace])</p></td>
<td><p>Performs a Boolean cut using another mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean_difference</span></code>(mesh[, inplace])</p></td>
<td><p>Combines two meshes and retains only the volume in common between the meshes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean_union</span></code>(mesh[, inplace])</p></td>
<td><p>Combines two meshes and attempts to create a manifold mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clean</span></code>([point_merging, merge_tol, …])</p></td>
<td><p>Cleans mesh by merging duplicate points, remove unused points, and/or remove degenerate cells.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip_with_plane</span></code>(origin, normal[, value, …])</p></td>
<td><p>DEPRECATED: Use <code class="docutils literal notranslate"><span class="pre">.clip</span></code> instead.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_arc_length</span></code>()</p></td>
<td><p>Computes the arc length over the length of the probed line.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_normals</span></code>([cell_normals, …])</p></td>
<td><p>Compute point and/or cell normals for a mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">curvature</span></code>([curv_type])</p></td>
<td><p>Returns the pointwise curvature of a mesh</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">decimate</span></code>(target_reduction[, …])</p></td>
<td><p>Reduces the number of triangles in a triangular mesh using vtkQuadricDecimation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">decimate_pro</span></code>(reduction[, feature_angle, …])</p></td>
<td><p>Reduce the number of triangles in a triangular mesh, forming a good approximation to the original geometry.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">delaunay_2d</span></code>([tol, alpha, offset, bound, inplace])</p></td>
<td><p>Apply a delaunay 2D filter along the best fitting plane</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">delauney_2d</span></code>()</p></td>
<td><p>DEPRECATED.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">edge_mask</span></code>(angle)</p></td>
<td><p>Returns a mask of the points of a surface mesh that have a surface angle greater than angle</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fill_holes</span></code>(hole_size[, inplace])</p></td>
<td><p>Fill holes in a pyvista.PolyData or vtk.vtkPolyData object.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">flip_normals</span></code>()</p></td>
<td><p>Flip normals of a triangular mesh by reversing the point ordering.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">geodesic</span></code>(start_vertex, end_vertex[, inplace])</p></td>
<td><p>Calculates the geodesic path betweeen two vertices using Dijkstra’s algorithm.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">geodesic_distance</span></code>(start_vertex, end_vertex)</p></td>
<td><p>Calculates the geodesic distance betweeen two vertices using Dijkstra’s algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_boundaries</span></code>(**kwargs)</p></td>
<td><p>Plots boundaries of a mesh</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_curvature</span></code>([curv_type])</p></td>
<td><p>Plots curvature</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_normals</span></code>([show_mesh, mag, flip, use_every])</p></td>
<td><p>Plot the point normals of a mesh.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">project_points_to_plane</span></code>([origin, normal, …])</p></td>
<td><p>Project points of this mesh to a plane</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">ray_trace</span></code>(origin, end_point[, first_point, …])</p></td>
<td><p>Performs a single ray trace calculation given a mesh and a line segment defined by an origin and end_point.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_points</span></code>(remove[, mode, keep_scalars, …])</p></td>
<td><p>Rebuild a mesh by removing points.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">smooth</span></code>([n_iter, convergence, edge_angle, …])</p></td>
<td><p>Adjust point coordinates using Laplacian smoothing.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">subdivide</span></code>(nsub[, subfilter, inplace])</p></td>
<td><p>Increase the number of triangles in a single, connected triangular mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tri_filter</span></code>([inplace])</p></td>
<td><p>DEPRECATED: use <code class="docutils literal notranslate"><span class="pre">.triangulate</span></code> instead</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangulate</span></code>([inplace])</p></td>
<td><p>Returns an all triangle mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">tube</span></code>([radius, scalars, capping, n_sides, …])</p></td>
<td><p>Generate a tube around each input line.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="pyvista.PolyDataFilters">
<em class="property">class </em><code class="sig-prename descclassname">pyvista.</code><code class="sig-name descname">PolyDataFilters</code><a class="headerlink" href="#pyvista.PolyDataFilters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.core.filters.DataSetFilters</span></code></p>
<dl class="method">
<dt id="pyvista.PolyDataFilters.boolean_add">
<code class="sig-name descname">boolean_add</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.boolean_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a mesh to the current mesh.  Does not attempt to “join”
the meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – The mesh to add.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>joinedmesh</strong> – Initial mesh and the new mesh when inplace=False.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.boolean_cut">
<code class="sig-name descname">boolean_cut</code><span class="sig-paren">(</span><em class="sig-param">cut</em>, <em class="sig-param">tolerance=1e-05</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.boolean_cut" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a Boolean cut using another mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cut</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – Mesh making the cut</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – The cut mesh when inplace=False</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.boolean_difference">
<code class="sig-name descname">boolean_difference</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.boolean_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines two meshes and retains only the volume in common
between the meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – The mesh to perform a union against.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>union</strong> – The union mesh when inplace=False.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.boolean_union">
<code class="sig-name descname">boolean_union</code><span class="sig-paren">(</span><em class="sig-param">mesh</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.boolean_union" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines two meshes and attempts to create a manifold mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – The mesh to perform a union against.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>union</strong> – The union mesh when inplace=False.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.clean">
<code class="sig-name descname">clean</code><span class="sig-paren">(</span><em class="sig-param">point_merging=True</em>, <em class="sig-param">merge_tol=None</em>, <em class="sig-param">lines_to_points=True</em>, <em class="sig-param">polys_to_lines=True</em>, <em class="sig-param">strips_to_polys=True</em>, <em class="sig-param">inplace=False</em>, <em class="sig-param">absolute=True</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.clean" title="Permalink to this definition">¶</a></dt>
<dd><p>Cleans mesh by merging duplicate points, remove unused
points, and/or remove degenerate cells.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>point_merging</strong> (<em>bool</em><em>, </em><em>optional</em>) – Enables point merging.  On by default.</p></li>
<li><p><strong>merge_tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Set merging tolarance.  When enabled merging is set to
absolute distance. If <code class="docutils literal notranslate"><span class="pre">absolute</span></code> is False, then the merging
tolerance is a fraction of the bounding box legnth. The alias
<code class="docutils literal notranslate"><span class="pre">tolerance</span></code> is also excepted.</p></li>
<li><p><strong>lines_to_points</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turn on/off conversion of degenerate lines to points.  Enabled by
default.</p></li>
<li><p><strong>polys_to_lines</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turn on/off conversion of degenerate polys to lines.  Enabled by
default.</p></li>
<li><p><strong>strips_to_polys</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turn on/off conversion of degenerate strips to polys.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.  Default True.</p></li>
<li><p><strong>absolute</strong> (<em>bool</em><em>, </em><em>optional</em>) – Control if <code class="docutils literal notranslate"><span class="pre">merge_tol</span></code> is an absolute distance or a fraction.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Cleaned mesh.  None when inplace=True</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.clip_with_plane">
<code class="sig-name descname">clip_with_plane</code><span class="sig-paren">(</span><em class="sig-param">origin</em>, <em class="sig-param">normal</em>, <em class="sig-param">value=0</em>, <em class="sig-param">invert=False</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.clip_with_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED: Use <code class="docutils literal notranslate"><span class="pre">.clip</span></code> instead.</p>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.compute_arc_length">
<code class="sig-name descname">compute_arc_length</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.compute_arc_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the arc length over the length of the probed line.
It adds a new point-data array named “arc_length” with the computed arc
length for each of the polylines in the input. For all other cell types,
the arc length is set to 0.</p>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.compute_normals">
<code class="sig-name descname">compute_normals</code><span class="sig-paren">(</span><em class="sig-param">cell_normals=True</em>, <em class="sig-param">point_normals=True</em>, <em class="sig-param">split_vertices=False</em>, <em class="sig-param">flip_normals=False</em>, <em class="sig-param">consistent_normals=True</em>, <em class="sig-param">auto_orient_normals=False</em>, <em class="sig-param">non_manifold_traversal=True</em>, <em class="sig-param">feature_angle=30.0</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.compute_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute point and/or cell normals for a mesh.</p>
<p>The filter can reorder polygons to insure consistent orientation across
polygon neighbors. Sharp edges can be split and points duplicated
with separate normals to give crisp (rendered) surface definition. It is
also possible to globally flip the normal orientation.</p>
<p>The algorithm works by determining normals for each polygon and then
averaging them at shared points. When sharp edges are present, the edges
are split and new points generated to prevent blurry edges (due to
Gouraud shading).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_normals</strong> (<em>bool</em><em>, </em><em>optional</em>) – Calculation of cell normals. Defaults to True.</p></li>
<li><p><strong>point_normals</strong> (<em>bool</em><em>, </em><em>optional</em>) – Calculation of point normals. Defaults to True.</p></li>
<li><p><strong>split_vertices</strong> (<em>bool</em><em>, </em><em>optional</em>) – Splitting of sharp edges. Defaults to False.</p></li>
<li><p><strong>flip_normals</strong> (<em>bool</em><em>, </em><em>optional</em>) – Set global flipping of normal orientation. Flipping modifies both
the normal direction and the order of a cell’s points. Defaults to
False.</p></li>
<li><p><strong>consistent_normals</strong> (<em>bool</em><em>, </em><em>optional</em>) – Enforcement of consistent polygon ordering. Defaults to True.</p></li>
<li><p><strong>auto_orient_normals</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turn on/off the automatic determination of correct normal
orientation. NOTE: This assumes a completely closed surface (i.e. no
boundary edges) and no non-manifold edges. If these constraints do
not hold, all bets are off. This option adds some computational
complexity, and is useful if you don’t want to have to inspect the
rendered image to determine whether to turn on the FlipNormals flag.
However, this flag can work with the FlipNormals flag, and if both
are set, all the normals in the output will point “inward”. Defaults
to False.</p></li>
<li><p><strong>non_manifold_traversal</strong> (<em>bool</em><em>, </em><em>optional</em>) – Turn on/off traversal across non-manifold edges. Changing this may
prevent problems where the consistency of polygonal ordering is
corrupted due to topological loops. Defaults to True.</p></li>
<li><p><strong>feature_angle</strong> (<em>float</em><em>, </em><em>optional</em>) – The angle that defines a sharp edge. If the difference in angle
across neighboring polygons is greater than this value, the shared
edge is considered “sharp”. Defaults to 30.0.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing. Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Updated mesh with cell and point normals if inplace=False</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Previous arrays named “Normals” will be overwritten.</p>
<p>Normals are computed only for polygons and triangle strips. Normals are
not computed for lines or vertices.</p>
<p>Triangle strips are broken up into triangle polygons. You may want to
restrip the triangles.</p>
<p>May be easier to run mesh.point_normals or mesh.cell_normals</p>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.curvature">
<code class="sig-name descname">curvature</code><span class="sig-paren">(</span><em class="sig-param">curv_type='mean'</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.curvature" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pointwise curvature of a mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>vtk.polydata</em>) – vtk polydata mesh</p></li>
<li><p><strong>string</strong><strong>, </strong><strong>optional</strong> (<em>curvature</em>) – One of the following strings
Mean
Gaussian
Maximum
Minimum</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>curvature</strong> – Curvature values</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.decimate">
<code class="sig-name descname">decimate</code><span class="sig-paren">(</span><em class="sig-param">target_reduction</em>, <em class="sig-param">volume_preservation=False</em>, <em class="sig-param">attribute_error=False</em>, <em class="sig-param">scalars=True</em>, <em class="sig-param">vectors=True</em>, <em class="sig-param">normals=False</em>, <em class="sig-param">tcoords=True</em>, <em class="sig-param">tensors=True</em>, <em class="sig-param">scalars_weight=0.1</em>, <em class="sig-param">vectors_weight=0.1</em>, <em class="sig-param">normals_weight=0.1</em>, <em class="sig-param">tcoords_weight=0.1</em>, <em class="sig-param">tensors_weight=0.1</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.decimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces the number of triangles in a triangular mesh using
vtkQuadricDecimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<em>vtk.PolyData</em>) – Mesh to decimate</p></li>
<li><p><strong>target_reduction</strong> (<em>float</em>) – Fraction of the original mesh to remove.
TargetReduction is set to 0.9, this filter will try to reduce
the data set to 10% of its original size and will remove 90%
of the input triangles.</p></li>
<li><p><strong>volume_preservation</strong> (<em>bool</em><em>, </em><em>optional</em>) – Decide whether to activate volume preservation which greatly reduces
errors in triangle normal direction. If off, volume preservation is
disabled and if AttributeErrorMetric is active, these errors can be
large. Defaults to False.</p></li>
<li><p><strong>attribute_error</strong> (<em>bool</em><em>, </em><em>optional</em>) – Decide whether to include data attributes in the error metric. If
off, then only geometric error is used to control the decimation.
Defaults to False.</p></li>
<li><p><strong>scalars</strong> (<em>bool</em><em>, </em><em>optional</em>) – If attribute errors are to be included in the metric (i.e.,
AttributeErrorMetric is on), then the following flags control which
attributes are to be included in the error calculation. Defaults to
True.</p></li>
<li><p><strong>vectors</strong> (<em>bool</em><em>, </em><em>optional</em>) – See scalars parameter. Defaults to True.</p></li>
<li><p><strong>normals</strong> (<em>bool</em><em>, </em><em>optional</em>) – See scalars parameter. Defaults to False.</p></li>
<li><p><strong>tcoords</strong> (<em>bool</em><em>, </em><em>optional</em>) – See scalars parameter. Defaults to True.</p></li>
<li><p><strong>tensors</strong> (<em>bool</em><em>, </em><em>optional</em>) – See scalars parameter. Defaults to True.</p></li>
<li><p><strong>scalars_weight</strong> (<em>float</em><em>, </em><em>optional</em>) – The scaling weight contribution of the scalar attribute. These
values are used to weight the contribution of the attributes towards
the error metric. Defaults to 0.1.</p></li>
<li><p><strong>vectors_weight</strong> (<em>float</em><em>, </em><em>optional</em>) – See scalars weight parameter. Defaults to 0.1.</p></li>
<li><p><strong>normals_weight</strong> (<em>float</em><em>, </em><em>optional</em>) – See scalars weight parameter. Defaults to 0.1.</p></li>
<li><p><strong>tcoords_weight</strong> (<em>float</em><em>, </em><em>optional</em>) – See scalars weight parameter. Defaults to 0.1.</p></li>
<li><p><strong>tensors_weight</strong> (<em>float</em><em>, </em><em>optional</em>) – See scalars weight parameter. Defaults to 0.1.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>outmesh</strong> – Decimated mesh.  None when inplace=True.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.decimate_pro">
<code class="sig-name descname">decimate_pro</code><span class="sig-paren">(</span><em class="sig-param">reduction</em>, <em class="sig-param">feature_angle=45.0</em>, <em class="sig-param">split_angle=75.0</em>, <em class="sig-param">splitting=True</em>, <em class="sig-param">pre_split_mesh=False</em>, <em class="sig-param">preserve_topology=False</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.decimate_pro" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduce the number of triangles in a triangular mesh, forming a good
approximation to the original geometry. Based on the algorithm originally
described in “Decimation of Triangle Meshes”, Proc Siggraph 92.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reduction</strong> (<em>float</em>) – Reduction factor. A value of 0.9 will leave 10 % of the original number
of vertices.</p></li>
<li><p><strong>feature_angle</strong> (<em>float</em><em>, </em><em>optional</em>) – Angle used to define what an edge is (i.e., if the surface normal between
two adjacent triangles is &gt;= feature_angle, an edge exists).</p></li>
<li><p><strong>split_angle</strong> (<em>float</em><em>, </em><em>optional</em>) – Angle used to control the splitting of the mesh. A split line exists
when the surface normals between two edge connected triangles are &gt;= split_angle.</p></li>
<li><p><strong>splitting</strong> (<em>bool</em><em>, </em><em>optional</em>) – Controls the splitting of the mesh at corners, along edges, at non-manifold
points, or anywhere else a split is required. Turning splitting off
will better preserve the original topology of the mesh, but may not
necessarily give the exact requested decimation.</p></li>
<li><p><strong>pre_split_mesh</strong> (<em>bool</em><em>, </em><em>optional</em>) – Separates the mesh into semi-planar patches, which are disconnected
from each other. This can give superior results in some cases. If pre_split_mesh
is set to True, the mesh is split with the specified split_angle. Otherwise
mesh splitting is deferred as long as possible.</p></li>
<li><p><strong>preserve_topology</strong> (<em>bool</em><em>, </em><em>optional</em>) – Controls topology preservation. If on, mesh splitting and hole elimination
will not occur. This may limit the maximum reduction that may be achieved.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Decimated mesh. None when inplace=True.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.delaunay_2d">
<code class="sig-name descname">delaunay_2d</code><span class="sig-paren">(</span><em class="sig-param">tol=1e-05</em>, <em class="sig-param">alpha=0.0</em>, <em class="sig-param">offset=1.0</em>, <em class="sig-param">bound=False</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.delaunay_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a delaunay 2D filter along the best fitting plane</p>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.delauney_2d">
<code class="sig-name descname">delauney_2d</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.delauney_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED. Please see <code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.PolyData.delaunay_2d()</span></code></p>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.edge_mask">
<code class="sig-name descname">edge_mask</code><span class="sig-paren">(</span><em class="sig-param">angle</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.edge_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a mask of the points of a surface mesh that have a surface
angle greater than angle</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>angle</strong> (<em>float</em>) – Angle to consider an edge.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.fill_holes">
<code class="sig-name descname">fill_holes</code><span class="sig-paren">(</span><em class="sig-param">hole_size</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.fill_holes" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill holes in a pyvista.PolyData or vtk.vtkPolyData object.</p>
<p>Holes are identified by locating boundary edges, linking them together
into loops, and then triangulating the resulting loops. Note that you
can specify an approximate limit to the size of the hole that can be
filled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hole_size</strong> (<em>float</em>) – Specifies the maximum hole size to fill. This is represented as a
radius to the bounding circumsphere containing the hole. Note that
this is an approximate area; the actual area cannot be computed
without first triangulating the hole.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return new mesh or overwrite input.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Mesh with holes filled.  None when inplace=True</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.flip_normals">
<code class="sig-name descname">flip_normals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.flip_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Flip normals of a triangular mesh by reversing the point ordering.</p>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.geodesic">
<code class="sig-name descname">geodesic</code><span class="sig-paren">(</span><em class="sig-param">start_vertex</em>, <em class="sig-param">end_vertex</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.geodesic" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the geodesic path betweeen two vertices using Dijkstra’s
algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_vertex</strong> (<em>int</em>) – Vertex index indicating the start point of the geodesic segment.</p></li>
<li><p><strong>end_vertex</strong> (<em>int</em>) – Vertex index indicating the end point of the geodesic segment.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>output</strong> – PolyData object consisting of the line segment between the two given
vertices.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.geodesic_distance">
<code class="sig-name descname">geodesic_distance</code><span class="sig-paren">(</span><em class="sig-param">start_vertex</em>, <em class="sig-param">end_vertex</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.geodesic_distance" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the geodesic distance betweeen two vertices using Dijkstra’s
algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_vertex</strong> (<em>int</em>) – Vertex index indicating the start point of the geodesic segment.</p></li>
<li><p><strong>end_vertex</strong> (<em>int</em>) – Vertex index indicating the end point of the geodesic segment.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>length</strong> – Length of the geodesic segment.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.plot_boundaries">
<code class="sig-name descname">plot_boundaries</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.plot_boundaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots boundaries of a mesh</p>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.plot_curvature">
<code class="sig-name descname">plot_curvature</code><span class="sig-paren">(</span><em class="sig-param">curv_type='mean'</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.plot_curvature" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots curvature</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>curvtype</strong> (<em>str</em><em>, </em><em>optional</em>) – <p>One of the following strings indicating curvature type</p>
<ul>
<li><p>Mean</p></li>
<li><p>Gaussian</p></li>
<li><p>Maximum</p></li>
<li><p>Minimum</p></li>
</ul>
</p></li>
<li><p><strong>**kwargs</strong> (<em>optional</em>) – See help(pyvista.plot)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>cpos</strong> – List of camera position, focal point, and view up</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.plot_normals">
<code class="sig-name descname">plot_normals</code><span class="sig-paren">(</span><em class="sig-param">show_mesh=True</em>, <em class="sig-param">mag=1.0</em>, <em class="sig-param">flip=False</em>, <em class="sig-param">use_every=1</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.plot_normals" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the point normals of a mesh.</p>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.project_points_to_plane">
<code class="sig-name descname">project_points_to_plane</code><span class="sig-paren">(</span><em class="sig-param">origin=None</em>, <em class="sig-param">normal=(0</em>, <em class="sig-param">0</em>, <em class="sig-param">1)</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.project_points_to_plane" title="Permalink to this definition">¶</a></dt>
<dd><p>Project points of this mesh to a plane</p>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.ray_trace">
<code class="sig-name descname">ray_trace</code><span class="sig-paren">(</span><em class="sig-param">origin</em>, <em class="sig-param">end_point</em>, <em class="sig-param">first_point=False</em>, <em class="sig-param">plot=False</em>, <em class="sig-param">off_screen=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.ray_trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a single ray trace calculation given a mesh and a line segment
defined by an origin and end_point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>origin</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – Start of the line segment.</p></li>
<li><p><strong>end_point</strong> (<em>np.ndarray</em><em> or </em><em>list</em>) – End of the line segment.</p></li>
<li><p><strong>first_point</strong> (<em>bool</em><em>, </em><em>optional</em>) – Returns intersection of first point only.</p></li>
<li><p><strong>plot</strong> (<em>bool</em><em>, </em><em>optional</em>) – Plots ray trace results</p></li>
<li><p><strong>off_screen</strong> (<em>bool</em><em>, </em><em>optional</em>) – Plots off screen.  Used for unit testing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>intersection_points</strong> (<em>np.ndarray</em>) – Location of the intersection points.  Empty array if no
intersections.</p></li>
<li><p><strong>intersection_cells</strong> (<em>np.ndarray</em>) – Indices of the intersection cells.  Empty array if no
intersections.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.remove_points">
<code class="sig-name descname">remove_points</code><span class="sig-paren">(</span><em class="sig-param">remove</em>, <em class="sig-param">mode='any'</em>, <em class="sig-param">keep_scalars=True</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.remove_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebuild a mesh by removing points.  Only valid for
all-triangle meshes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>remove</strong> (<em>np.ndarray</em>) – If remove is a bool array, points that are True will be
removed.  Otherwise, it is treated as a list of indices.</p></li>
<li><p><strong>mode</strong> (<em>str</em><em>, </em><em>optional</em>) – When ‘all’, only faces containing all points flagged for
removal will be removed.  Default ‘all’</p></li>
<li><p><strong>keep_scalars</strong> (<em>bool</em><em>, </em><em>optional</em>) – When True, point and cell scalars will be passed on to the
new mesh.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mesh</strong> (<em>pyvista.PolyData</em>) – Mesh without the points flagged for removal.  Not returned
when inplace=False.</p></li>
<li><p><strong>ridx</strong> (<em>np.ndarray</em>) – Indices of new points relative to the original mesh.  Not
returned when inplace=False.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.smooth">
<code class="sig-name descname">smooth</code><span class="sig-paren">(</span><em class="sig-param">n_iter=20</em>, <em class="sig-param">convergence=0.0</em>, <em class="sig-param">edge_angle=15</em>, <em class="sig-param">feature_angle=45</em>, <em class="sig-param">boundary_smoothing=True</em>, <em class="sig-param">feature_smoothing=False</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust point coordinates using Laplacian smoothing.
The effect is to “relax” the mesh, making the cells better shaped and
the vertices more evenly distributed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_iter</strong> (<em>int</em>) – Number of iterations for Laplacian smoothing,</p></li>
<li><p><strong>convergence</strong> (<em>float</em><em>, </em><em>optional</em>) – Convergence criterion for the iteration process. Smaller numbers
result in more smoothing iterations. Range from (0 to 1).</p></li>
<li><p><strong>edge_angle</strong> (<em>float</em><em>, </em><em>optional</em>) – Edge angle to control smoothing along edges (either interior or boundary).</p></li>
<li><p><strong>feature_angle</strong> (<em>float</em><em>, </em><em>optional</em>) – Feature angle for sharp edge identification.</p></li>
<li><p><strong>boundary_smoothing</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean flag to control smoothing of boundary edges.</p></li>
<li><p><strong>feature_smoothing</strong> (<em>bool</em><em>, </em><em>optional</em>) – Boolean flag to control smoothing of feature edges.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Decimated mesh. None when inplace=True.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.subdivide">
<code class="sig-name descname">subdivide</code><span class="sig-paren">(</span><em class="sig-param">nsub</em>, <em class="sig-param">subfilter='linear'</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.subdivide" title="Permalink to this definition">¶</a></dt>
<dd><p>Increase the number of triangles in a single, connected triangular
mesh.</p>
<p>Uses one of the following vtk subdivision filters to subdivide a mesh.
vtkButterflySubdivisionFilter
vtkLoopSubdivisionFilter
vtkLinearSubdivisionFilter</p>
<p>Linear subdivision results in the fastest mesh subdivision, but it
does not smooth mesh edges, but rather splits each triangle into 4
smaller triangles.</p>
<p>Butterfly and loop subdivision perform smoothing when dividing, and may
introduce artifacts into the mesh when dividing.</p>
<p>Subdivision filter appears to fail for multiple part meshes.  Should
be one single mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nsub</strong> (<em>int</em>) – Number of subdivisions.  Each subdivision creates 4 new triangles,
so the number of resulting triangles is nface*4**nsub where nface
is the current number of faces.</p></li>
<li><p><strong>subfilter</strong> (<em>string</em><em>, </em><em>optional</em>) – Can be one of the following: ‘butterfly’, ‘loop’, ‘linear’</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – pyvista polydata object.  None when inplace=True</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Polydata object</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyvista</span> <span class="k">import</span> <span class="n">examples</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyvista</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span> <span class="o">=</span> <span class="n">pyvista</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">examples</span><span class="o">.</span><span class="n">planefile</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">submesh</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;loop&#39;</span><span class="p">)</span> <span class="c1"># doctest:+SKIP</span>
</pre></div>
</div>
<p>alternatively, update mesh in-place</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mesh</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;loop&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># doctest:+SKIP</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.tri_filter">
<code class="sig-name descname">tri_filter</code><span class="sig-paren">(</span><em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.tri_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>DEPRECATED: use <code class="docutils literal notranslate"><span class="pre">.triangulate</span></code> instead</p>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.triangulate">
<code class="sig-name descname">triangulate</code><span class="sig-paren">(</span><em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.triangulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an all triangle mesh.  More complex polygons will be broken
down into triangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Mesh containing only triangles.  None when inplace=True</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.PolyDataFilters.tube">
<code class="sig-name descname">tube</code><span class="sig-paren">(</span><em class="sig-param">radius=None</em>, <em class="sig-param">scalars=None</em>, <em class="sig-param">capping=True</em>, <em class="sig-param">n_sides=20</em>, <em class="sig-param">radius_factor=10</em>, <em class="sig-param">preference='point'</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.PolyDataFilters.tube" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a tube around each input line. The radius of the tube can be
set to linearly vary with a scalar value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>radius</strong> (<em>float</em>) – Minimum tube radius (minimum because the tube radius may vary).</p></li>
<li><p><strong>scalars</strong> (<em>str</em><em>, </em><em>optional</em>) – Scalar array by which the radius varies</p></li>
<li><p><strong>capping</strong> (<em>bool</em>) – Turn on/off whether to cap the ends with polygons. Default True.</p></li>
<li><p><strong>n_sides</strong> (<em>int</em>) – Set the number of sides for the tube. Minimum of 3.</p></li>
<li><p><strong>radius_factor</strong> (<em>float</em>) – Maximum tube radius in terms of a multiple of the minimum radius.</p></li>
<li><p><strong>preference</strong> (<em>str</em>) – The field preference when searching for the scalar array by name</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Tube-filtered mesh. None when inplace=True.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData">pyvista.PolyData</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="unstructuredgrid-filters">
<h2>UnstructuredGrid Filters<a class="headerlink" href="#unstructuredgrid-filters" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="#pyvista.UnstructuredGridFilters" title="pyvista.UnstructuredGridFilters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.UnstructuredGridFilters</span></code></a> is inherited by
<a class="reference internal" href="point-grids.html#pyvista.UnstructuredGrid" title="pyvista.UnstructuredGrid"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.UnstructuredGrid</span></code></a> making all the the following filters
available as callable methods directly from any UnstructuredGrid mesh.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">delaunay_2d</span></code>([tol, alpha, offset, bound])</p></td>
<td><p>Apply a delaunay 2D filter along the best fitting plane.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="pyvista.UnstructuredGridFilters">
<em class="property">class </em><code class="sig-prename descclassname">pyvista.</code><code class="sig-name descname">UnstructuredGridFilters</code><a class="headerlink" href="#pyvista.UnstructuredGridFilters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.core.filters.DataSetFilters</span></code></p>
<dl class="method">
<dt id="pyvista.UnstructuredGridFilters.delaunay_2d">
<code class="sig-name descname">delaunay_2d</code><span class="sig-paren">(</span><em class="sig-param">tol=1e-05</em>, <em class="sig-param">alpha=0.0</em>, <em class="sig-param">offset=1.0</em>, <em class="sig-param">bound=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.UnstructuredGridFilters.delaunay_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a delaunay 2D filter along the best fitting plane. This
extracts the grid’s points and perfoms the triangulation on those alone.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="composite-filters">
<h2>Composite Filters<a class="headerlink" href="#composite-filters" title="Permalink to this headline">¶</a></h2>
<p>These are filters that can be applied to composite datasets, i.e.
<a class="reference internal" href="composite.html#pyvista.MultiBlock" title="pyvista.MultiBlock"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.MultiBlock</span></code></a>. The <a class="reference internal" href="#pyvista.CompositeFilters" title="pyvista.CompositeFilters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.CompositeFilters</span></code></a> class
inherits many but not all of the filters from <a class="reference internal" href="#pyvista.DataSetFilters" title="pyvista.DataSetFilters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pyvista.DataSetFilters</span></code></a>.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell_centers</span></code>([vertex])</p></td>
<td><p>Generate points at the center of the cells in this dataset.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell_data_to_point_data</span></code>([pass_cell_data])</p></td>
<td><p>Transforms cell data (i.e., data specified per cell) into point data (i.e., data specified at cell points).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip</span></code>([normal, origin, invert, value, inplace])</p></td>
<td><p>Clip a dataset by a plane by specifying the origin and normal.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clip_box</span></code>([bounds, invert, factor])</p></td>
<td><p>Clips a dataset by a bounding box defined by the bounds.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">combine</span></code>([merge_points])</p></td>
<td><p>Appends all blocks into a single unstructured grid.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_cell_sizes</span></code>([length, area, volume])</p></td>
<td><p>This filter computes sizes for 1D (length), 2D (area) and 3D (volume) cells.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">elevation</span></code>([low_point, high_point, …])</p></td>
<td><p>Generate scalar values on a dataset.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_geometry</span></code>()</p></td>
<td><p>Combines the geomertry of all blocks into a single <code class="docutils literal notranslate"><span class="pre">PolyData</span></code> object.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline</span></code>([generate_faces, nested])</p></td>
<td><p>Produces an outline of the full extent for the all blocks in this composite dataset.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">outline_corners</span></code>([factor, nested])</p></td>
<td><p>Produces an outline of the corners for the all blocks in this composite dataset.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">point_data_to_cell_data</span></code>([pass_point_data])</p></td>
<td><p>Transforms point data (i.e., data specified per node) into cell data (i.e., data specified within cells).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice</span></code>([normal, origin, generate_triangles, …])</p></td>
<td><p>Slice a dataset by a plane at the specified origin and normal vector orientation.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_along_axis</span></code>([n, axis, tolerance, …])</p></td>
<td><p>Create many slices of the input dataset along a specified axis.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_along_line</span></code>(line[, generate_triangles, …])</p></td>
<td><p>Slices a dataset using a polyline/spline as the path.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_orthogonal</span></code>([x, y, z, …])</p></td>
<td><p>Creates three orthogonal slices through the dataset on the three caresian planes.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">triangulate</span></code>([inplace])</p></td>
<td><p>Returns an all triangle mesh.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">wireframe</span></code>()</p></td>
<td><p>Extract all the internal/external edges of the dataset as PolyData.</p></td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="pyvista.CompositeFilters">
<em class="property">class </em><code class="sig-prename descclassname">pyvista.</code><code class="sig-name descname">CompositeFilters</code><a class="headerlink" href="#pyvista.CompositeFilters" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>An internal class to manage filtes/algorithms for composite datasets.</p>
<dl class="method">
<dt id="pyvista.CompositeFilters.cell_centers">
<code class="sig-name descname">cell_centers</code><span class="sig-paren">(</span><em class="sig-param">vertex=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.cell_centers" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate points at the center of the cells in this dataset.
These points can be used for placing glyphs / vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vertex</strong> (<em>bool</em>) – Enable/disable the generation of vertex cells.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.cell_data_to_point_data">
<code class="sig-name descname">cell_data_to_point_data</code><span class="sig-paren">(</span><em class="sig-param">pass_cell_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.cell_data_to_point_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms cell data (i.e., data specified per cell) into point data
(i.e., data specified at cell points).
The method of transformation is based on averaging the data values of
all cells using a particular point. Optionally, the input cell data can
be passed through to the output as well.</p>
<p>See aslo: <a class="reference internal" href="#pyvista.DataSetFilters.point_data_to_cell_data" title="pyvista.DataSetFilters.point_data_to_cell_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.DataSetFilters.point_data_to_cell_data()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pass_cell_data</strong> (<em>bool</em>) – If enabled, pass the input cell data through to the output</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.clip">
<code class="sig-name descname">clip</code><span class="sig-paren">(</span><em class="sig-param">normal='x'</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">invert=True</em>, <em class="sig-param">value=0.0</em>, <em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.clip" title="Permalink to this definition">¶</a></dt>
<dd><p>Clip a dataset by a plane by specifying the origin and normal. If no
parameters are given the clip will occur in the center of that dataset</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normal</strong> (<em>tuple</em><em>(</em><em>float</em><em>) or </em><em>str</em>) – Length 3 tuple for the normal vector direction. Can also be
specified as a string conventional direction such as <code class="docutils literal notranslate"><span class="pre">'x'</span></code> for
<code class="docutils literal notranslate"><span class="pre">(1,0,0)</span></code> or <code class="docutils literal notranslate"><span class="pre">'-x'</span></code> for <code class="docutils literal notranslate"><span class="pre">(-1,0,0)</span></code>, etc.</p></li>
<li><p><strong>origin</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – The center <code class="docutils literal notranslate"><span class="pre">(x,y,z)</span></code> coordinate of the plane on which the clip
occurs</p></li>
<li><p><strong>invert</strong> (<em>bool</em>) – Flag on whether to flip/invert the clip</p></li>
<li><p><strong>value</strong> (<em>float:</em>) – Set the clipping value of the implicit function (if clipping with
implicit function) or scalar value (if clipping with scalars).
The default value is 0.0.</p></li>
<li><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning nothing.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.clip_box">
<code class="sig-name descname">clip_box</code><span class="sig-paren">(</span><em class="sig-param">bounds=None</em>, <em class="sig-param">invert=True</em>, <em class="sig-param">factor=0.35</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.clip_box" title="Permalink to this definition">¶</a></dt>
<dd><p>Clips a dataset by a bounding box defined by the bounds. If no bounds
are given, a corner of the dataset bounds will be removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>bounds</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – Length 6 iterable of floats: (xmin, xmax, ymin, ymax, zmin, zmax)</p></li>
<li><p><strong>invert</strong> (<em>bool</em>) – Flag on whether to flip/invert the clip</p></li>
<li><p><strong>factor</strong> (<em>float</em><em>, </em><em>optional</em>) – If bounds are not given this is the factor along each axis to
extract the default box.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.combine">
<code class="sig-name descname">combine</code><span class="sig-paren">(</span><em class="sig-param">merge_points=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.combine" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends all blocks into a single unstructured grid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>merge_points</strong> (<em>bool</em><em>, </em><em>optional</em>) – Merge coincidental points.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.compute_cell_sizes">
<code class="sig-name descname">compute_cell_sizes</code><span class="sig-paren">(</span><em class="sig-param">length=True</em>, <em class="sig-param">area=True</em>, <em class="sig-param">volume=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.compute_cell_sizes" title="Permalink to this definition">¶</a></dt>
<dd><p>This filter computes sizes for 1D (length), 2D (area) and 3D (volume)
cells.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>length</strong> (<em>bool</em>) – Specify whether or not to compute the length of 1D cells.</p></li>
<li><p><strong>area</strong> (<em>bool</em>) – Specify whether or not to compute the area of 2D cells.</p></li>
<li><p><strong>volume</strong> (<em>bool</em>) – Specify whether or not to compute the volume of 3D cells.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.elevation">
<code class="sig-name descname">elevation</code><span class="sig-paren">(</span><em class="sig-param">low_point=None</em>, <em class="sig-param">high_point=None</em>, <em class="sig-param">scalar_range=None</em>, <em class="sig-param">preference='point'</em>, <em class="sig-param">set_active=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.elevation" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate scalar values on a dataset.  The scalar values lie within a
user specified range, and are generated by computing a projection of
each dataset point onto a line.
The line can be oriented arbitrarily.
A typical example is to generate scalars based on elevation or height
above a plane.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>low_point</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The low point of the projection line in 3D space. Default is bottom
center of the dataset. Otherwise pass a length 3 tuple(float).</p></li>
<li><p><strong>high_point</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The high point of the projection line in 3D space. Default is top
center of the dataset. Otherwise pass a length 3 tuple(float).</p></li>
<li><p><strong>scalar_range</strong> (<em>str</em><em> or </em><em>tuple</em><em>(</em><em>float</em><em>)</em><em>, </em><em>optional</em>) – The scalar range to project to the low and high points on the line
that will be mapped to the dataset. If None given, the values will
be computed from the elevation (Z component) range between the
high and low points. Min and max of a range can be given as a length
2 tuple(float). If <code class="docutils literal notranslate"><span class="pre">str</span></code> name of scalara array present in the
dataset given, the valid range of that array will be used.</p></li>
<li><p><strong>preference</strong> (<em>str</em><em>, </em><em>optional</em>) – When a scalar name is specified for <code class="docutils literal notranslate"><span class="pre">scalar_range</span></code>, this is the
perfered scalar type to search for in the dataset.
Must be either ‘point’ or ‘cell’.</p></li>
<li><p><strong>set_active</strong> (<em>bool</em><em>, </em><em>optional</em>) – A boolean flag on whethter or not to set the new <cite>Elevation</cite> scalar
as the active scalar array on the output dataset.</p></li>
</ul>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This will create a scalar array named <cite>Elevation</cite> on the point data of
the input dataset and overasdf write an array named <cite>Elevation</cite> if present.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.extract_geometry">
<code class="sig-name descname">extract_geometry</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.extract_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines the geomertry of all blocks into a single <code class="docutils literal notranslate"><span class="pre">PolyData</span></code>
object. Place this filter at the end of a pipeline before a polydata
consumer such as a polydata mapper to extract geometry from all blocks
and append them to one polydata object.</p>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.outline">
<code class="sig-name descname">outline</code><span class="sig-paren">(</span><em class="sig-param">generate_faces=False</em>, <em class="sig-param">nested=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.outline" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces an outline of the full extent for the all blocks in this
composite dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>generate_faces</strong> (<em>bool</em><em>, </em><em>optional</em>) – Generate solid faces for the box. This is off by default</p></li>
<li><p><strong>nested</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, these creates individual outlines for each nested dataset</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.outline_corners">
<code class="sig-name descname">outline_corners</code><span class="sig-paren">(</span><em class="sig-param">factor=0.2</em>, <em class="sig-param">nested=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.outline_corners" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces an outline of the corners for the all blocks in this
composite dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>factor</strong> (<em>float</em><em>, </em><em>optional</em>) – controls the relative size of the corners to the length of the
corresponding bounds</p></li>
<li><p><strong>ested</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, these creates individual outlines for each nested dataset</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.point_data_to_cell_data">
<code class="sig-name descname">point_data_to_cell_data</code><span class="sig-paren">(</span><em class="sig-param">pass_point_data=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.point_data_to_cell_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms point data (i.e., data specified per node) into cell data
(i.e., data specified within cells).
Optionally, the input point data can be passed through to the output.</p>
<p>See aslo: <a class="reference internal" href="#pyvista.DataSetFilters.cell_data_to_point_data" title="pyvista.DataSetFilters.cell_data_to_point_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.DataSetFilters.cell_data_to_point_data()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pass_point_data</strong> (<em>bool</em>) – If enabled, pass the input point data through to the output</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.slice">
<code class="sig-name descname">slice</code><span class="sig-paren">(</span><em class="sig-param">normal='x'</em>, <em class="sig-param">origin=None</em>, <em class="sig-param">generate_triangles=False</em>, <em class="sig-param">contour=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice a dataset by a plane at the specified origin and normal vector
orientation. If no origin is specified, the center of the input dataset will
be used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>normal</strong> (<em>tuple</em><em>(</em><em>float</em><em>) or </em><em>str</em>) – Length 3 tuple for the normal vector direction. Can also be
specified as a string conventional direction such as <code class="docutils literal notranslate"><span class="pre">'x'</span></code> for
<code class="docutils literal notranslate"><span class="pre">(1,0,0)</span></code> or <code class="docutils literal notranslate"><span class="pre">'-x'</span></code> for <code class="docutils literal notranslate"><span class="pre">(-1,0,0)`</span></code>, etc.</p></li>
<li><p><strong>origin</strong> (<em>tuple</em><em>(</em><em>float</em><em>)</em>) – The center (x,y,z) coordinate of the plane on which the slice occurs</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.slice_along_axis">
<code class="sig-name descname">slice_along_axis</code><span class="sig-paren">(</span><em class="sig-param">n=5</em>, <em class="sig-param">axis='x'</em>, <em class="sig-param">tolerance=None</em>, <em class="sig-param">generate_triangles=False</em>, <em class="sig-param">contour=False</em>, <em class="sig-param">bounds=None</em>, <em class="sig-param">center=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.slice_along_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create many slices of the input dataset along a specified axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of slices to create</p></li>
<li><p><strong>axis</strong> (<em>str</em><em> or </em><em>int</em>) – The axis to generate the slices along. Perpendicular to the slices.
Can be string name (<code class="docutils literal notranslate"><span class="pre">'x'</span></code>, <code class="docutils literal notranslate"><span class="pre">'y'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'z'</span></code>) or axis index
(<code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, or <code class="docutils literal notranslate"><span class="pre">2</span></code>).</p></li>
<li><p><strong>tolerance</strong> (<em>float</em><em>, </em><em>optional</em>) – The toleranceerance to the edge of the dataset bounds to create the slices</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.slice_along_line">
<code class="sig-name descname">slice_along_line</code><span class="sig-paren">(</span><em class="sig-param">line</em>, <em class="sig-param">generate_triangles=False</em>, <em class="sig-param">contour=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.slice_along_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Slices a dataset using a polyline/spline as the path. This also works
for lines generated with <a class="reference internal" href="../utilities/geometric.html#pyvista.Line" title="pyvista.Line"><code class="xref py py-func docutils literal notranslate"><span class="pre">pyvista.Line()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>line</strong> (<a class="reference internal" href="points.html#pyvista.PolyData" title="pyvista.PolyData"><em>pyvista.PolyData</em></a>) – A PolyData object containing one single PolyLine cell.</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.slice_orthogonal">
<code class="sig-name descname">slice_orthogonal</code><span class="sig-paren">(</span><em class="sig-param">x=None</em>, <em class="sig-param">y=None</em>, <em class="sig-param">z=None</em>, <em class="sig-param">generate_triangles=False</em>, <em class="sig-param">contour=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.slice_orthogonal" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates three orthogonal slices through the dataset on the three
caresian planes. Yields a MutliBlock dataset of the three slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>float</em>) – The X location of the YZ slice</p></li>
<li><p><strong>y</strong> (<em>float</em>) – The Y location of the XZ slice</p></li>
<li><p><strong>z</strong> (<em>float</em>) – The Z location of the XY slice</p></li>
<li><p><strong>generate_triangles</strong> (<em>bool</em><em>, </em><em>optional</em>) – If this is enabled (<code class="docutils literal notranslate"><span class="pre">False</span></code> by default), the output will be
triangles otherwise, the output will be the intersection polygons.</p></li>
<li><p><strong>contour</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, apply a <code class="docutils literal notranslate"><span class="pre">contour</span></code> filter after slicing</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.triangulate">
<code class="sig-name descname">triangulate</code><span class="sig-paren">(</span><em class="sig-param">inplace=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.triangulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an all triangle mesh.  More complex polygons will be broken
down into triangles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>inplace</strong> (<em>bool</em><em>, </em><em>optional</em>) – Updates mesh in-place while returning <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>mesh</strong> – Mesh containing only triangles. <code class="docutils literal notranslate"><span class="pre">None</span></code> when <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="point-grids.html#pyvista.UnstructuredGrid" title="pyvista.UnstructuredGrid">pyvista.UnstructuredGrid</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pyvista.CompositeFilters.wireframe">
<code class="sig-name descname">wireframe</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyvista.CompositeFilters.wireframe" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract all the internal/external edges of the dataset as PolyData.
This produces a full wireframe representation of the input dataset.</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../plotting/index.html" class="btn btn-neutral float-right" title="Plotting" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="composite.html" class="btn btn-neutral float-left" title="Composite Datasets" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017-2019, The PyVista Developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>